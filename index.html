<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Productivity Timer with Breaks</title>
  <audio id="studySound" src="https://commondatastorage.googleapis.com/codeskulptor-demos/riceracer_assets/music/start.ogg" preload="auto"></audio>
  <audio id="breakSound" src="https://commondatastorage.googleapis.com/codeskulptor-demos/riceracer_assets/music/start.ogg" preload="auto"></audio>
  <style>
    /* Base Reset */
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    /* Body Styles */
    body {
      font-family: 'Roboto', Arial, sans-serif;
      background: #f3f4f7;
      color: #333;
      display: flex;
      flex-direction: column;
      min-height: 100vh;
    }

    /* Header Styles */
    header {
      background: linear-gradient(135deg, #1d4ed8, #2563eb);
      color: white;
      padding: 20px;
      text-align: center;
      font-size: 28px;
      font-weight: bold;
      box-shadow: 0 4px 10px rgba(0, 0, 0, 0.15);
    }

    /* Main Container */
    main {
      flex: 1;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      padding: 20px;
    }

    /* Card Styles */
    .card {
      width: 100%;
      max-width: 700px;
      background: white;
      border-radius: 12px;
      box-shadow: 0 6px 16px rgba(0, 0, 0, 0.1);
      padding: 25px;
      margin-bottom: 20px;
      transition: transform 0.3s, box-shadow 0.3s;
    }

    .card:hover {
      transform: translateY(-5px);
      box-shadow: 0 12px 24px rgba(0, 0, 0, 0.15);
    }

    /* Form Elements */
    label, h2 {
      color: #444;
      font-weight: bold;
      margin-bottom: 8px;
      display: block;
    }

    select, input, button {
      width: 100%;
      padding: 12px;
      margin-bottom: 15px;
      border: 1px solid #ddd;
      border-radius: 8px;
      font-size: 16px;
      transition: all 0.3s;
    }

    select:focus, input:focus {
      border-color: #2563eb;
      outline: none;
      box-shadow: 0 0 4px rgba(37, 99, 235, 0.5);
    }

    button {
      background: #2563eb;
      color: white;
      font-weight: bold;
      cursor: pointer;
      border: none;
      transition: background 0.3s;
      width: 20%
    }

    button:hover {
      background: #1d4ed8;
    }

    button:disabled {
      background: #ccc;
      cursor: not-allowed;
    }

    /* Task List */
    ul {
      list-style: none;
      padding: 0;
    }

    li {
      display: flex;
      align-items: center;
      justify-content: space-between;
      margin-bottom: 12px;
      padding: 8px 12px;
      border: 1px solid #ddd;
      border-radius: 6px;
      background: #f9f9f9;
      transition: box-shadow 0.3s, background 0.3s;
    }

    li:hover {
      background: #eef2f7;
      box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
    }

    li label {
      font-size: 16px;
      color: #333;
      margin-right: 10px;
      flex: 1;
    }

    li .custom-checkbox {
      position: relative;
      width: 20px;
      height: 20px;
      border: 2px solid #0073e6;
      border-radius: 4px;
      background: #fff;
      cursor: pointer;
      transition: background-color 0.3s, box-shadow 0.3s;
    }

    li .custom-checkbox:after {
      content: '';
      position: absolute;
      top: 4px;
      left: 6px;
      width: 6px;
      height: 10px;
      border: solid #0073e6;
      border-width: 0 2px 2px 0;
      transform: rotate(45deg);
      opacity: 0;
      transition: opacity 0.3s;
    }

    li input[type="checkbox"] {
      display: none;
    }

    li input[type="checkbox"]:checked + .custom-checkbox {
      background: #0073e6;
    }

    li input[type="checkbox"]:checked + .custom-checkbox:after {
      opacity: 1;
    }

    /* Canvas Styles */
    #canvas {
      position: relative;
      width: 100%;
      max-width: 640px;
      height: 360px;
      background: #1f2937;
      border-radius: 12px;
      margin-top: 20px;
      box-shadow: 0 6px 16px rgba(0, 0, 0, 0.1);
    }

    /* Video Container */
    .video-container {
      position: relative;
      width: 640px;
      height: 480px;
      margin: auto;
    }

    /* Control Buttons */
    .control-buttons {
      display: flex;
      gap: 10px;
      justify-content: center;
      margin-top: 20px;
      flex-wrap: wrap;
    }

    .control-buttons button {
      width: auto;
      min-width: 120px;
      padding: 10px 15px;
    }

    /* Screen Settings Panel */
    #screenSettingsPanel {
      position: absolute;
      top: 20px;
      right: 20px;
      background-color: rgba(0,0,0,0.7);
      color: white;
      padding: 10px;
      border-radius: 5px;
      z-index: 1000;
      font-family: 'Roboto', Arial, sans-serif;
    }

    #screenSettingsPanel label {
      display: block;
      margin: 5px 0;
      color: white;
    }

    #screenSettingsPanel input {
      width: 60px;
      padding: 5px;
      margin-left: 5px;
    }

    #screenSettingsPanel button {
      width: 100%;
      margin-top: 10px;
    }

    /* Routine Styles */
    .routine-container {
      display: flex;
      flex-direction: column;
      gap: 10px;
    }
    
    .routine-day {
      display: flex;
      align-items: center;
      gap: 10px;
    }
    
    .routine-day label {
      min-width: 100px;
      margin-bottom: 0;
    }
    
    .routine-tasks {
      flex-grow: 1;
    }
    
    /* Tabs */
    .tabs {
      display: flex;
      margin-bottom: 15px;
    }
    
    .tab {
      padding: 10px 20px;
      cursor: pointer;
      background: #ddd;
      border-radius: 5px 5px 0 0;
      margin-right: 5px;
    }
    
    .tab.active {
      background: #2563eb;
      color: white;
    }
    
    .tab-content {
      display: none;
    }
    
    .tab-content.active {
      display: block;
    }

    /* Time Tracking */
    .time-tracker {
      position: absolute;
      bottom: 20px;
      left: 20px;
      background: rgba(0, 0, 0, 0.5);
      color: white;
      padding: 10px;
      border-radius: 5px;
      font-family: 'Roboto', Arial, sans-serif;
      font-size: 14px;
    }

    /* Responsive Design */
    @media (max-width: 768px) {
      body {
        padding: 10px;
      }

      header {
        font-size: 22px;
        padding: 15px;
      }

      .card {
        padding: 20px;
      }

      select, input, button {
        font-size: 14px;
        padding: 10px;
      }

      h2 {
        font-size: 18px;
      }

      #canvas {
        height: 200px;
        margin-top: 10px;
      }

      .control-buttons button {
        width: 45%;
      }

      .video-container {
        width: 100%;
        height: auto;
      }
    }

    @media (max-width: 480px) {
      header {
        font-size: 18px;
      }

      .card {
        padding: 15px;
      }

      select, input, button {
        font-size: 12px;
        padding: 8px;
      }

      h2 {
        font-size: 16px;
      }

      #canvas {
        height: 150px;
      }

      li {
        flex-direction: column;
        align-items: flex-start;
      }

      li label {
        margin-bottom: 5px;
        font-size: 14px;
      }

      li .delete-task {
        align-self: flex-end;
        margin-top: 5px;
      }
    }
  </style>
</head>
<body>
  <header>
    Pomodaro
  </header>
  <main>
    <!-- Timer Settings -->
    <div class="card">
      <h2>Timer Settings</h2>
      <label for="focusTime">Focus Time (minutes):</label>
      <select id="focusTime">
        <option value="25">25</option>
        <option value="30">30</option>
        <option value="40">40</option>
      </select>
      <label for="shortBreak">Short Break (minutes):</label>
      <select id="shortBreak">
        <option value="5">5</option>
        <option value="10">10</option>
      </select>
      <label for="longBreak">Long Break (minutes):</label>
      <select id="longBreak">
        <option value="15">15</option>
        <option value="20">20</option>
      </select>
      <label for="soundVolume">Notification Volume:</label>
      <input type="range" id="soundVolume" min="0" max="1" step="0.1" value="0.5">
    </div>
  
    <!-- Task List with Tabs -->
    <div class="card">
      <div class="tabs">
        <div class="tab active" data-tab="tasks">Tasks</div>
        <div class="tab" data-tab="routine">Daily Routine</div>
      </div>
      
      <!-- Tasks Tab -->
      <div id="tasks" class="tab-content active">
        <h2>Task List</h2>
        <input type="text" id="taskInput" placeholder="Add a new task">
        <button id="addTask">Add Task</button>
        <ul id="taskList"></ul>
      </div>
      
      <!-- Routine Tab -->
      <div id="routine" class="tab-content">
        <h2>Daily Routine</h2>
        <div class="routine-container" id="routineContainer">
          <!-- Days will be added here by JavaScript -->
        </div>
        <button id="saveRoutine">Save Routine</button>
      </div>
    </div>
  
    <!-- Timer Overlay Section -->
    <div class="video-container">
      <canvas id="canvas"></canvas>
    </div>
      
    <!-- Control Buttons -->
    <div class="control-buttons">
      <button id="startRecording">Start Recording</button>
      <button id="stopRecording" disabled>Stop Recording</button>
      <button id="pauseTimer">Pause Timer</button>
      <button id="shareScreen">Share Screen</button>
      <button id="stopScreenShare" disabled>Stop Screen Share</button>
    </div>
  </main>

<script>
// Select Elements
// IndexedDB variables
let db;
const DB_NAME = 'PomodoroRecorderDB';
const STORE_NAME = 'videoChunks';
const SESSION_KEY = 'currentRecordingSession';

const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');
const startRecordingButton = document.getElementById('startRecording');
const stopRecordingButton = document.getElementById('stopRecording');
const focusTimeSelect = document.getElementById('focusTime');
const shortBreakSelect = document.getElementById('shortBreak');
const longBreakSelect = document.getElementById('longBreak');
const taskInput = document.getElementById('taskInput');
const taskList = document.getElementById('taskList');
const addTaskButton = document.getElementById('addTask');
const pauseTimerButton = document.getElementById('pauseTimer');
const shareScreenButton = document.getElementById('shareScreen');
const stopScreenShareButton = document.getElementById('stopScreenShare');
const routineContainer = document.getElementById('routineContainer');
const saveRoutineButton = document.getElementById('saveRoutine');
const tabs = document.querySelectorAll('.tab');
const tabContents = document.querySelectorAll('.tab-content');

// Audio elements
const studySound = document.getElementById('studySound');
const breakSound = document.getElementById('breakSound');
document.getElementById('soundVolume').addEventListener('input', (e) => {
  studySound.volume = e.target.value;
  breakSound.volume = e.target.value;
});

// Set initial volume (0.5 = 50%)
studySound.volume = 0.5;
breakSound.volume = 0.5;

// Create video elements
const webcamVideo = document.createElement('video');
let screenVideo = document.createElement('video');

// Variables
let videoStream;
let screenStream;
let mediaRecorder;
let recordedChunks = [];
let timerInterval;
let timeRemaining;
let tasks = [];
let routineTasks = {
  monday: [], tuesday: [], wednesday: [], thursday: [],
  friday: [], saturday: [], sunday: []
};
let recording = false;
let isTimerPaused = false;
let isScreenSharing = false;
let timerState = 'Focus'; // 'Focus', 'ShortBreak', 'LongBreak'

// Daily Time Tracking
let dailyTimeData = {};
let currentDate = new Date().toISOString().split('T')[0];
let dailyTimeGoal = 8 * 3600; // 8 hours in seconds (default)
let lastSavedTime = 0;
let lastTimeUpdate = Date.now();

// Initialize Canvas
canvas.width = 640;
canvas.height = 480;

// Initialize IndexedDB
async function initDB() {
  return new Promise((resolve, reject) => {
    const request = indexedDB.open(DB_NAME, 1);
    
    request.onerror = (event) => {
      console.error("Database error:", event.target.error);
      reject(event.target.error);
    };
    
    request.onsuccess = (event) => {
      db = event.target.result;
      resolve(db);
    };
    
    request.onupgradeneeded = (event) => {
      const db = event.target.result;
      if (!db.objectStoreNames.contains(STORE_NAME)) {
        db.createObjectStore(STORE_NAME, { autoIncrement: true });
      }
    };
  });
}

// Load all data
function loadInitialData() {
  // Load tasks
  const savedTasks = localStorage.getItem('tasks');
  tasks = savedTasks ? JSON.parse(savedTasks) : [];
  
  // Load routine
  const savedRoutine = localStorage.getItem('routineTasks');
  routineTasks = savedRoutine ? JSON.parse(savedRoutine) : {
    monday: [], tuesday: [], wednesday: [], thursday: [],
    friday: [], saturday: [], sunday: []
  };
  
  // Load daily time data
  const savedTimeData = localStorage.getItem('dailyTimeData');
  dailyTimeData = savedTimeData ? JSON.parse(savedTimeData) : {};
  
  // Load daily goal
  const savedGoal = localStorage.getItem('dailyTimeGoal');
  dailyTimeGoal = savedGoal ? parseInt(savedGoal, 10) : 8 * 3600;
  
  // Initialize current day
  currentDate = new Date().toISOString().split('T')[0];
  if (!dailyTimeData[currentDate]) {
    dailyTimeData[currentDate] = 0;
  }
  
  renderTaskList();
  renderRoutine();
  loadTodaysRoutine();
}

// Save daily time data
function saveDailyTime() {
  localStorage.setItem('dailyTimeData', JSON.stringify(dailyTimeData));
}

// Update time tracking with accurate elapsed time
function updateTimeTracking() {
  if (!recording || isTimerPaused) {
    lastTimeUpdate = Date.now();
    return;
  }

  // Check for new day
  const today = new Date().toISOString().split('T')[0];
  if (today !== currentDate) {
    currentDate = today;
    if (!dailyTimeData[currentDate]) {
      dailyTimeData[currentDate] = 0;
    }
    saveDailyTime();
  }

  // Calculate elapsed time
  const now = Date.now();
  const elapsedSeconds = Math.floor((now - lastTimeUpdate) / 1000);
  
  if (elapsedSeconds >= 1) {
    dailyTimeData[currentDate] += elapsedSeconds;
    lastSavedTime += elapsedSeconds;
    lastTimeUpdate = now;
    
    // Check daily goal
    if (dailyTimeData[currentDate] >= dailyTimeGoal) {
      showGoalNotification();
    }
    
    // Save periodically
    if (lastSavedTime >= 60) {
      saveDailyTime();
      lastSavedTime = 0;
    }
  }
}

// Daily goal notification
function showGoalNotification() {
  if (Notification.permission === "granted") {
    new Notification("Daily Goal Reached!", {
      body: `You've completed your ${formatTime(dailyTimeGoal)} goal for today!`,
      icon: 'https://cdn-icons-png.flaticon.com/512/2913/2913103.png'
    });
  } else if (Notification.permission !== "denied") {
    Notification.requestPermission().then(permission => {
      if (permission === "granted") {
        showGoalNotification();
      }
    });
  }
}

// Set daily goal
function setDailyGoal(hours) {
  dailyTimeGoal = hours * 3600;
  localStorage.setItem('dailyTimeGoal', dailyTimeGoal.toString());
}

// Format time
function formatTime(seconds) {
  const hrs = Math.floor(seconds / 3600);
  const mins = Math.floor((seconds % 3600) / 60);
  const secs = seconds % 60;
  return `${hrs.toString().padStart(2, '0')}:${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
}

// Draw time tracker with goal progress
function drawTimeTracker() {
  const today = new Date().toISOString().split('T')[0];
  const timeSpent = dailyTimeData[today] || 0;
  const progress = Math.min(timeSpent / dailyTimeGoal, 1);
  
  // Time display
  ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
  ctx.fillRect(10, canvas.height - 70, 300, 60);
  ctx.fillStyle = 'white';
  ctx.font = '16px Arial';
  ctx.fillText(`Today: ${formatTime(timeSpent)}`, 20, canvas.height - 50);
  ctx.fillText(`Goal: ${formatTime(dailyTimeGoal)} (${Math.round(progress * 100)}%)`, 20, canvas.height - 30);
  
  // Progress bar
  ctx.fillStyle = 'rgba(255,255,255,0.3)';
  ctx.fillRect(10, canvas.height - 20, 300, 10);
  ctx.fillStyle = progress >= 1 ? 'gold' : 'lime';
  ctx.fillRect(10, canvas.height - 20, 300 * progress, 10);
}

// Add goal setting UI
function addGoalControls() {
  const goalContainer = document.createElement('div');
  goalContainer.className = 'goal-controls';
  goalContainer.style.position = 'fixed';
  goalContainer.style.bottom = '20px';
  goalContainer.style.right = '20px';
  goalContainer.style.backgroundColor = 'rgba(0,0,0,0.7)';
  goalContainer.style.padding = '10px';
  goalContainer.style.borderRadius = '5px';
  goalContainer.style.color = 'white';
  goalContainer.style.zIndex = '1000';
  
  goalContainer.innerHTML = `
    <h3 style="margin-top:0;">Daily Goal</h3>
    <input type="number" id="dailyGoalHours" min="1" max="12" value="${dailyTimeGoal / 3600}" style="width:50px;">
    <button id="setGoal" style="margin-left:5px;">Set Hours</button>
  `;
  document.body.appendChild(goalContainer);
  
  document.getElementById('setGoal').addEventListener('click', () => {
    const hours = parseInt(document.getElementById('dailyGoalHours').value);
    if (hours >= 1 && hours <= 12) {
      setDailyGoal(hours);
      alert(`Daily goal set to ${hours} hours`);
    } else {
      alert('Please enter a value between 1 and 12 hours');
    }
  });
}

// Initialize video
async function initializeVideo() {
  try {
    videoStream = await navigator.mediaDevices.getUserMedia({ 
      video: { 
        width: { ideal: canvas.width },
        height: { ideal: canvas.height }
      } 
    });
    webcamVideo.srcObject = videoStream;
    webcamVideo.play();
    drawFrame();
    
    // Request notification permission
    if (Notification.permission !== "granted") {
      Notification.requestPermission();
    }
  } catch (error) {
    console.error('Error accessing video stream:', error);
    // Fallback display
    ctx.fillStyle = 'black';
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    ctx.fillStyle = 'white';
    ctx.font = '20px Arial';
    ctx.fillText('Camera access denied or not available', 50, canvas.height/2);
    drawFrame();
  }
}

// Main drawing function
function drawFrame() {
  // Clear canvas
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  
  // Draw webcam video if available
  if (videoStream && webcamVideo.readyState >= webcamVideo.HAVE_ENOUGH_DATA) {
    try {
      ctx.drawImage(webcamVideo, 0, 0, canvas.width, canvas.height);
    } catch (e) {
      console.error('Error drawing video:', e);
    }
  }
  
  // Draw screen share if active
  if (isScreenSharing && screenStream && screenVideo.readyState >= screenVideo.HAVE_ENOUGH_DATA) {
    try {
      ctx.drawImage(
        screenVideo, 
        screenPosition.x, 
        screenPosition.y, 
        screenSize.width, 
        screenSize.height
      );
      
      // Add border to screen share
      ctx.strokeStyle = 'red';
      ctx.lineWidth = 2;
      ctx.strokeRect(
        screenPosition.x, 
        screenPosition.y, 
        screenSize.width, 
        screenSize.height
      );
    } catch (e) {
      console.log('Error drawing screen share:', e);
    }
  }
  
  // Draw overlays
  drawTimerOverlay();
  drawTaskOverlay();
  drawProgressCircle();
  drawTaskProgressCircle();
  drawRecordingIndicator();
  drawTimeTracker();
  
  requestAnimationFrame(drawFrame);
}

// Timer functions
function startTimer(duration, state) {
  timerState = state;
  timeRemaining = duration * 60;
  lastTimeUpdate = Date.now();
  updateTimerDisplay();
  
  clearInterval(timerInterval);
  timerInterval = setInterval(() => {
    updateTimer();
    updateTimeTracking();
  }, 1000);
  
  // Play appropriate sound
  if (state === 'Focus') {
    studySound.currentTime = 0;
    studySound.play().catch(e => console.log("Audio play failed:", e));
  } else {
    breakSound.currentTime = 0;
    breakSound.play().catch(e => console.log("Audio play failed:", e));
  }
}

function updateTimer() {
  if (isTimerPaused) return;

  const now = Date.now();
  const elapsedSeconds = Math.floor((now - lastTimeUpdate) / 1000);
  
  if (elapsedSeconds >= 1) {
    timeRemaining -= elapsedSeconds;
    lastTimeUpdate = now;
    updateTimerDisplay();
    
    if (timeRemaining <= 0) {
      clearInterval(timerInterval);
      handleTimerEnd(timerState);
    }
  }
}

function updateTimerDisplay() {
  // Handled by drawTimerOverlay()
}

function handleTimerEnd(state) {
  if (Notification.permission === "granted") {
    const title = state === 'Focus' ? 'Time for a break!' : 'Break time over!';
    const body = state === 'Focus' 
      ? 'Your focus session has ended. Take a short break.'
      : 'Your break has ended. Time to focus again.';
    
    new Notification(title, { 
      body: body,
      icon: 'https://cdn-icons-png.flaticon.com/512/2913/2913103.png'
    });
  }
  
  // Start next timer
  if (state === 'Focus') {
    startTimer(parseInt(shortBreakSelect.value || 5, 10), 'ShortBreak');
  } else {
    startTimer(parseInt(focusTimeSelect.value || 25, 10), 'Focus');
  }
}

// Drawing functions
function drawTimerOverlay() {
  const minutes = Math.floor(timeRemaining / 60);
  const seconds = timeRemaining % 60;
  const timerText = `${timerState}: ${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
  
  ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
  ctx.fillRect(10, 10, 250, 50);
  ctx.fillStyle = 'white';
  ctx.font = '20px Arial';
  ctx.fillText(timerText, 20, 40);
}

function drawProgressCircle() {
  const totalTime = timerState === 'Focus'
    ? parseInt(focusTimeSelect.value || 25, 10) * 60
    : timerState === 'ShortBreak'
    ? parseInt(shortBreakSelect.value || 5, 10) * 60
    : parseInt(longBreakSelect.value || 15, 10) * 60;

  const progress = totalTime ? (totalTime - timeRemaining) / totalTime : 0;

  const centerX = canvas.width - 100;
  const centerY = canvas.height - 100;
  const radius = 40;

  // Background Circle
  ctx.beginPath();
  ctx.arc(centerX, centerY, radius, 0, 2 * Math.PI);
  ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
  ctx.fill();

  // Progress Circle
  ctx.beginPath();
  ctx.arc(centerX, centerY, radius, -Math.PI / 2, -Math.PI / 2 + (2 * Math.PI * progress));
  ctx.lineWidth = 8;
  ctx.strokeStyle = 'green';
  ctx.stroke();

  // Percentage Text
  ctx.fillStyle = 'white';
  ctx.font = '16px Arial';
  ctx.fillText(`${Math.round(progress * 100)}%`, centerX - 20, centerY + 5);
}

function drawTaskProgressCircle() {
  const completedTasks = tasks.filter(task => task.completed).length;
  const totalTasks = tasks.length;
  const progress = totalTasks > 0 ? completedTasks / totalTasks : 0;

  const centerX = 100;
  const centerY = canvas.height - 100;
  const radius = 40;

  // Background Circle
  ctx.beginPath();
  ctx.arc(centerX, centerY, radius, 0, 2 * Math.PI);
  ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
  ctx.fill();

  // Progress Circle
  ctx.beginPath();
  ctx.arc(centerX, centerY, radius, -Math.PI / 2, -Math.PI / 2 + (2 * Math.PI * progress));
  ctx.lineWidth = 8;
  ctx.strokeStyle = 'blue';
  ctx.stroke();

  // Percentage Text
  ctx.fillStyle = 'white';
  ctx.font = '16px Arial';
  ctx.fillText(`${Math.round(progress * 100)}%`, centerX - 20, centerY + 5);
}

function drawTaskOverlay() {
  ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
  ctx.fillRect(10, 70, 300, 200);
  ctx.fillStyle = 'white';
  ctx.font = '16px Arial';

  tasks.forEach((task, index) => {
    const status = task.completed ? '✔' : '❌';
    ctx.fillText(`${index + 1}. ${task.text} (${status})`, 20, 100 + index * 20);
  });
}

function drawRecordingIndicator() {
  if (recording) {
    ctx.fillStyle = 'rgba(255, 0, 0, 0.5)';
    ctx.fillRect(canvas.width - 120, 10, 110, 50);
    ctx.fillStyle = 'white';
    ctx.font = '16px Arial';
    ctx.fillText('Recording', canvas.width - 110, 40);
  }
}

// Task functions
addTaskButton.addEventListener('click', () => {
  const taskText = taskInput.value.trim();
  if (taskText) {
    tasks.push({ text: taskText, completed: false });
    renderTaskList();
    saveTasks();
    taskInput.value = '';
  }
});

function renderTaskList() {
  taskList.innerHTML = '';
  tasks.forEach((task, index) => {
    const li = document.createElement('li');
    const checkbox = document.createElement('input');
    checkbox.type = 'checkbox';
    checkbox.id = `task-${index}`;
    checkbox.checked = task.completed;
    checkbox.addEventListener('change', () => {
      tasks[index].completed = checkbox.checked;
      saveTasks();
    });

    const label = document.createElement('label');
    label.htmlFor = `task-${index}`;
    label.textContent = task.text;

    const deleteButton = document.createElement('button');
    deleteButton.className = 'delete-task';
    deleteButton.textContent = 'Delete';
    deleteButton.addEventListener('click', () => {
      tasks.splice(index, 1);
      renderTaskList();
      saveTasks();
    });

    li.appendChild(checkbox);
    li.appendChild(label);
    li.appendChild(deleteButton);
    taskList.appendChild(li);
  });
}

function saveTasks() {
  localStorage.setItem('tasks', JSON.stringify(tasks));
}

// Routine functions
function renderRoutine() {
  routineContainer.innerHTML = '';
  
  const days = [
    { id: 'monday', name: 'Monday' },
    { id: 'tuesday', name: 'Tuesday' },
    { id: 'wednesday', name: 'Wednesday' },
    { id: 'thursday', name: 'Thursday' },
    { id: 'friday', name: 'Friday' },
    { id: 'saturday', name: 'Saturday' },
    { id: 'sunday', name: 'Sunday' }
  ];
  
  days.forEach(day => {
    const dayContainer = document.createElement('div');
    dayContainer.className = 'routine-day';
    
    const label = document.createElement('label');
    label.textContent = day.name;
    
    const input = document.createElement('input');
    input.type = 'text';
    input.className = 'routine-tasks';
    input.placeholder = 'Enter tasks separated by commas';
    input.value = routineTasks[day.id].join(', ');
    
    dayContainer.appendChild(label);
    dayContainer.appendChild(input);
    routineContainer.appendChild(dayContainer);
  });
}

function saveRoutine() {
  const inputs = document.querySelectorAll('.routine-tasks');
  
  inputs.forEach(input => {
    const dayId = input.previousElementSibling.textContent.toLowerCase();
    const tasks = input.value.split(',').map(task => task.trim()).filter(task => task);
    routineTasks[dayId] = tasks;
  });
  
  localStorage.setItem('routineTasks', JSON.stringify(routineTasks));
  alert('Routine saved!');
}

function loadTodaysRoutine() {
  const days = ['sunday', 'monday', 'tuesday', 'wednesday', 'thursday', 'friday', 'saturday'];
  const today = new Date().getDay();
  const todaysDay = days[today];
  
  // Check if we've already loaded today's routine
  const lastRoutineLoad = localStorage.getItem('lastRoutineLoad');
  const todayDate = new Date().toDateString();
  
  if (lastRoutineLoad !== todayDate) {
    const todaysTasks = routineTasks[todaysDay];
    if (todaysTasks && todaysTasks.length > 0) {
      tasks = [...tasks, ...todaysTasks.map(task => ({ text: task, completed: false }))];
      renderTaskList();
      saveTasks();
      localStorage.setItem('lastRoutineLoad', todayDate);
    }
  }
}

// Recording functions
startRecordingButton.addEventListener('click', async () => {
  try {
    if (!db) await initDB();
    
    const previousChunks = await loadChunksFromDB();
    recordedChunks = previousChunks;
    
    const combinedStream = canvas.captureStream();
    mediaRecorder = new MediaRecorder(combinedStream, { mimeType: 'video/webm' });

    mediaRecorder.ondataavailable = (event) => {
      if (event.data.size > 0) {
        recordedChunks.push(event.data);
        if (recordedChunks.length % 5 === 0) {
          saveChunksToDB(recordedChunks);
        }
      }
    };

    mediaRecorder.onstop = async () => {
      await finalizeRecording();
    };

    mediaRecorder.start(1000);
    recording = true;
    
    const savedSession = loadRecordingSession();
    if (savedSession) {
      timerState = savedSession.timerState;
      timeRemaining = savedSession.timeRemaining;
      startTimer(Math.ceil(timeRemaining / 60), timerState);
    } else {
      const focusTime = parseInt(focusTimeSelect.value || 25, 10);
      startTimer(focusTime, 'Focus');
    }
    
    saveRecordingSession();
    startRecordingButton.disabled = true;
    stopRecordingButton.disabled = false;
  } catch (error) {
    console.error("Error starting recording:", error);
    alert("Failed to start recording. Please try again.");
  }
});

stopRecordingButton.addEventListener('click', async () => {
  if (mediaRecorder && mediaRecorder.state !== 'inactive') {
    mediaRecorder.stop();
  }
  recording = false;
  startRecordingButton.disabled = false;
  stopRecordingButton.disabled = true;
  await saveChunksToDB(recordedChunks);
  clearRecordingSession();
});

// Screen sharing functions
let screenPosition = { x: canvas.width - 200, y: 70 };
let screenSize = { width: 180, height: 120 };

shareScreenButton.addEventListener('click', async () => {
  try {
    screenStream = await navigator.mediaDevices.getDisplayMedia({
      video: { width: { ideal: 1920 }, height: { ideal: 1080 } },
      audio: false
    });
    
    screenVideo = document.createElement('video');
    screenVideo.srcObject = screenStream;
    screenVideo.play();
    
    isScreenSharing = true;
    shareScreenButton.disabled = true;
    stopScreenShareButton.disabled = false;
    
    createScreenSettingsPanel();
  } catch (error) {
    console.error('Error sharing screen:', error);
  }
});

stopScreenShareButton.addEventListener('click', () => {
  if (screenStream) {
    screenStream.getTracks().forEach(track => track.stop());
    screenStream = null;
  }
  isScreenSharing = false;
  shareScreenButton.disabled = false;
  stopScreenShareButton.disabled = true;
  
  const panel = document.getElementById('screenSettingsPanel');
  if (panel) panel.remove();
});

function createScreenSettingsPanel() {
  const panel = document.createElement('div');
  panel.id = 'screenSettingsPanel';
  panel.style.position = 'absolute';
  panel.style.top = '20px';
  panel.style.right = '20px';
  panel.style.backgroundColor = 'rgba(0,0,0,0.7)';
  panel.style.color = 'white';
  panel.style.padding = '10px';
  panel.style.borderRadius = '5px';
  panel.style.zIndex = '1000';
  
  panel.innerHTML = `
    <h3 style="margin-top:0;">Screen Settings</h3>
    <label>Width: <input type="number" id="screenWidth" value="${screenSize.width}" min="100" max="400"></label><br>
    <label>Height: <input type="number" id="screenHeight" value="${screenSize.height}" min="75" max="300"></label><br>
    <label>X Position: <input type="number" id="screenX" value="${screenPosition.x}" min="0" max="${canvas.width}"></label><br>
    <label>Y Position: <input type="number" id="screenY" value="${screenPosition.y}" min="0" max="${canvas.height}"></label><br>
    <button id="applyScreenSettings">Apply</button>
  `;
  
  document.body.appendChild(panel);
  
  document.getElementById('applyScreenSettings').addEventListener('click', () => {
    screenSize.width = parseInt(document.getElementById('screenWidth').value);
    screenSize.height = parseInt(document.getElementById('screenHeight').value);
    screenPosition.x = parseInt(document.getElementById('screenX').value);
    screenPosition.y = parseInt(document.getElementById('screenY').value);
  });
}

// IndexedDB functions
async function saveChunksToDB(chunks) {
  return new Promise((resolve, reject) => {
    const transaction = db.transaction([STORE_NAME], 'readwrite');
    const store = transaction.objectStore(STORE_NAME);
    
    const clearRequest = store.clear();
    
    clearRequest.onsuccess = () => {
      chunks.forEach((chunk, index) => {
        store.put(chunk, index);
      });
      
      transaction.oncomplete = () => resolve();
      transaction.onerror = (event) => reject(event.target.error);
    };
    
    clearRequest.onerror = (event) => reject(event.target.error);
  });
}

async function loadChunksFromDB() {
  return new Promise((resolve, reject) => {
    const transaction = db.transaction([STORE_NAME], 'readonly');
    const store = transaction.objectStore(STORE_NAME);
    const request = store.getAll();
    
    request.onsuccess = (event) => resolve(event.target.result || []);
    request.onerror = (event) => reject(event.target.error);
  });
}

function saveRecordingSession() {
  localStorage.setItem(SESSION_KEY, JSON.stringify({
    recording: true,
    timerState,
    timeRemaining,
    totalTimeSpent: dailyTimeData[currentDate] || 0
  }));
}

function loadRecordingSession() {
  const session = localStorage.getItem(SESSION_KEY);
  return session ? JSON.parse(session) : null;
}

function clearRecordingSession() {
  localStorage.removeItem(SESSION_KEY);
}

async function finalizeRecording() {
  try {
    const blob = new Blob(recordedChunks, { type: 'video/webm' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = `pomodoro-session-${new Date().toISOString().split('T')[0]}.webm`;
    document.body.appendChild(a);
    a.click();
    
    setTimeout(() => {
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
    }, 100);
    
    const transaction = db.transaction([STORE_NAME], 'readwrite');
    const store = transaction.objectStore(STORE_NAME);
    store.clear();
    
    recordedChunks = [];
    saveDailyTime();
    clearRecordingSession();
  } catch (error) {
    console.error("Error finalizing recording:", error);
    alert("Failed to save recording. Please try again.");
  }
}

// Pause timer functionality
pauseTimerButton.addEventListener('click', () => {
  isTimerPaused = !isTimerPaused;
  pauseTimerButton.textContent = isTimerPaused ? 'Resume Timer' : 'Pause Timer';
  
  if (isTimerPaused) {
    clearInterval(timerInterval);
    if (mediaRecorder && recording) {
      mediaRecorder.pause();
    }
  } else {
    lastTimeUpdate = Date.now();
    timerInterval = setInterval(() => {
      updateTimer();
      updateTimeTracking();
    }, 1000);
    if (mediaRecorder && recording) {
      mediaRecorder.resume();
    }
  }
});

// Tab functionality
tabs.forEach(tab => {
  tab.addEventListener('click', () => {
    tabs.forEach(t => t.classList.remove('active'));
    tabContents.forEach(c => c.classList.remove('active'));
    
    tab.classList.add('active');
    const tabId = tab.getAttribute('data-tab');
    document.getElementById(tabId).classList.add('active');
  });
});

// Theme toggle
const themeToggle = document.createElement('button');
themeToggle.className = 'theme-toggle';
themeToggle.textContent = '🌗';
themeToggle.style.position = 'fixed';
themeToggle.style.top = '20px';
themeToggle.style.right = '20px';
themeToggle.style.zIndex = '1000';
document.body.appendChild(themeToggle);

themeToggle.addEventListener('click', () => {
  document.body.classList.toggle('dark-theme');
  document.body.style.background = document.body.classList.contains('dark-theme') ? '#1f2937' : '#f3f4f7';
});

// Full screen button
const fullScreenButton = document.createElement('button');
fullScreenButton.className = 'full-screen-button';
fullScreenButton.textContent = 'Full Screen';
fullScreenButton.style.position = 'fixed';
fullScreenButton.style.top = '60px';
fullScreenButton.style.right = '20px';
fullScreenButton.style.zIndex = '1000';
document.body.appendChild(fullScreenButton);

fullScreenButton.addEventListener('click', () => {
  if (canvas.requestFullscreen) {
    canvas.requestFullscreen();
  } else if (canvas.webkitRequestFullscreen) {
    canvas.webkitRequestFullscreen();
  }
});

// Save data before unload
window.addEventListener('beforeunload', async (event) => {
  if (recording && mediaRecorder && mediaRecorder.state !== 'inactive') {
    mediaRecorder.requestData();
    await new Promise(resolve => setTimeout(resolve, 100));
    await saveChunksToDB(recordedChunks);
    saveRecordingSession();
    saveDailyTime();
  }
});

// Initialize when page loads
window.addEventListener('load', async () => {
  await initDB();
  initializeVideo();
  loadInitialData();
  addGoalControls();
  
  const savedSession = loadRecordingSession();
  if (savedSession && savedSession.recording) {
    if (confirm("Unfinished session found. Resume?")) {
      startRecordingButton.click();
    } else {
      clearRecordingSession();
      const transaction = db.transaction([STORE_NAME], 'readwrite');
      const store = transaction.objectStore(STORE_NAME);
      store.clear();
    }
  }
});
</script>
</body>
</html>
